---
import '../styles/global.css';
import { generateSEOTags, generateHreflang, generateStructuredData, type SEOProps } from '../lib/seo';
import { getLocaleFromUrl, type Locale } from '../lib/i18n';

interface Props extends SEOProps {
  class?: string;
}

const { title, description, locale, canonical, ogImage, ogType, twitterCard, class: className } = Astro.props;

const seo = generateSEOTags({
  title,
  description, 
  locale,
  canonical,
  ogImage,
  ogType,
  twitterCard
});

const hreflang = generateHreflang(canonical || '');
const structuredData = generateStructuredData(locale);
---

<!doctype html>
<html lang={locale} dir="ltr">
  <head>
    <meta charset="UTF-8" />
    <meta name="description" content={seo.description} />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" type="image/png" href="/images/favicon.png" />
    <meta name="generator" content={Astro.generator} />
    
    <!-- SEO Meta Tags -->
    <title>{seo.title}</title>
    <meta name="description" content={seo.description} />
    {canonical && <link rel="canonical" href={seo.canonical} />}
    
    <!-- Open Graph -->
    <meta property="og:title" content={seo.og.title} />
    <meta property="og:description" content={seo.og.description} />
    <meta property="og:type" content={seo.og.type} />
    <meta property="og:image" content={seo.og.image} />
    <meta property="og:url" content={seo.og.url} />
    <meta property="og:locale" content={seo.og.locale} />
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content={seo.twitter.card} />
    <meta name="twitter:title" content={seo.twitter.title} />
    <meta name="twitter:description" content={seo.twitter.description} />
    <meta name="twitter:image" content={seo.twitter.image} />
    
    <!-- Hreflang -->
    {hreflang.map(({ hreflang: lang, href }) => (
      <link rel="alternate" hreflang={lang} href={href} />
    ))}
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Radio+Canada+Big:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&display=swap" rel="stylesheet">
    
    <!-- Structured Data -->
    {structuredData.map((schema) => (
      <script type="application/ld+json" set:html={JSON.stringify(schema)} />
    ))}
    
    <!-- Performance Optimizations -->
    <meta name="theme-color" content="#CE1A28" />
    <meta name="color-scheme" content="light" />
  </head>
  <body class={`${className || ''} pt-0`}>
    <slot />
  </body>
</html>

<style>
  /* Critical CSS for above-the-fold content */
  html {
    font-display: swap;
  }
  
  /* Prevent flash of unstyled content */
  body {
    visibility: hidden;
  }
  
  body.loaded {
    visibility: visible;
  }
</style>

<script>
  // Mark body as loaded to prevent FOUC
  document.addEventListener('DOMContentLoaded', () => {
    document.body.classList.add('loaded');
    
    // Debug: Check all images on page
    setTimeout(() => {
      console.log('🔍 GLOBAL DEBUG: All Images on Page...');
      const allImages = document.querySelectorAll('img');
      console.log(`📷 Total images found: ${allImages.length}`);
      
      allImages.forEach((img, index) => {
        const status = img.complete && img.naturalWidth > 0 ? 'loaded' : 'failed/loading';
        console.log(`${index + 1}. ${img.src} - ${status} - ${img.naturalWidth}x${img.naturalHeight}`);
        
        if (!img.complete || img.naturalWidth === 0) {
          console.warn(`⚠️ Image issue: ${img.src}`);
        }
      });
      
      // Check background images
      const elementsWithBg = document.querySelectorAll('*');
      let bgCount = 0;
      elementsWithBg.forEach(el => {
        const style = window.getComputedStyle(el);
        if (style.backgroundImage && style.backgroundImage !== 'none') {
          bgCount++;
          console.log(`🎨 Background image ${bgCount}: ${style.backgroundImage}`);
        }
      });
      
      console.log(`🎨 Total background images: ${bgCount}`);
    }, 3000);
  });
  
  // Performance monitoring
  if (typeof window !== 'undefined') {
    // Monitor CLS
    let cls = 0;
    new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        const layoutShiftEntry = entry as any; // Type assertion for layout-shift specific properties
        if (!layoutShiftEntry.hadRecentInput) {
          cls += layoutShiftEntry.value;
        }
      }
    }).observe({ type: 'layout-shift', buffered: true });
    
    // Log performance metrics in development
    if (import.meta.env.DEV) {
      window.addEventListener('load', () => {
        console.log('CLS:', cls);
        console.log('Performance:', performance.getEntriesByType('navigation')[0]);
      });
    }
  }
</script>


